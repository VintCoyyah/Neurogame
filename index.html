<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEURO SEQUENCE | Cognitive Calibration</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto+Mono:wght@300;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-deep: #05070a;
            --bg-panel: rgba(20, 30, 50, 0.6);
            --neon-blue: #00f3ff;
            --neon-lime: #0aff0a;
            --neon-pink: #ff0055;
            --text-main: #e0e6ed;
            --glass-border: 1px solid rgba(0, 243, 255, 0.2);
        }

        body {
            background-color: var(--bg-deep);
            color: var(--text-main);
            font-family: 'Roboto Mono', monospace;
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            background-image: radial-gradient(circle at center, #0f1724 0%, #05070a 100%);
        }

        /* --- HUD & UI --- */
        .hud-container {
            width: 90%;
            max-width: 600px;
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            padding: 15px;
            background: var(--bg-panel);
            backdrop-filter: blur(10px);
            border: var(--glass-border);
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.1);
        }

        .hud-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .hud-label {
            font-size: 0.7rem;
            color: var(--neon-blue);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .hud-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
        }

        /* --- GAME GRID --- */
        .game-area {
            position: relative;
            width: 90vmin; /* Responsive square */
            height: 90vmin;
            max-width: 600px;
            max-height: 600px;
            background: rgba(255,255,255,0.02);
            border-radius: 12px;
            padding: 10px;
            display: grid;
            gap: 10px;
            /* Grid columns defined via JS */
        }

        /* --- TILES --- */
        .tile {
            background: rgba(0, 243, 255, 0.1);
            border: 1px solid rgba(0, 243, 255, 0.3);
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Orbitron', sans-serif;
            font-size: 2rem;
            color: var(--neon-blue);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            user-select: none;
            position: relative;
            overflow: hidden;
        }

        .tile:hover {
            background: rgba(0, 243, 255, 0.2);
            box-shadow: 0 0 10px var(--neon-blue);
        }

        /* Animasi Masuk */
        .tile.spawn {
            animation: popIn 0.4s ease-out backwards;
        }

        /* Fase Masking (Sembunyi) */
        .tile.masked {
            color: transparent; /* Sembunyikan angka */
            background: #ffffff; /* Putih terang saat masked */
            border-color: #fff;
            box-shadow: 0 0 15px rgba(255,255,255,0.8);
            transform: rotateY(180deg);
        }
        
        .tile.masked::after {
            content: ''; /* Simbol generik */
            position: absolute;
            width: 10px;
            height: 10px;
            background: var(--bg-deep);
            transform: rotate(45deg);
        }

        /* Benar */
        .tile.correct {
            background: rgba(10, 255, 10, 0.2);
            border-color: var(--neon-lime);
            color: var(--neon-lime);
            transform: rotateY(0deg) scale(1.1);
            box-shadow: 0 0 20px var(--neon-lime);
        }

        /* Salah */
        .tile.wrong {
            background: rgba(255, 0, 85, 0.4);
            border-color: var(--neon-pink);
            animation: glitch 0.3s linear infinite;
        }

        /* --- OVERLAY --- */
        #start-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 7, 10, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        h1 {
            font-family: 'Orbitron';
            color: var(--neon-blue);
            text-shadow: 0 0 20px var(--neon-blue);
            margin-bottom: 30px;
            text-align: center;
        }

        .btn {
            background: transparent;
            border: 2px solid var(--neon-blue);
            color: var(--neon-blue);
            padding: 15px 40px;
            font-family: 'Orbitron';
            font-size: 1.2rem;
            cursor: pointer;
            text-transform: uppercase;
            transition: 0.3s;
        }

        .btn:hover {
            background: var(--neon-blue);
            color: var(--bg-deep);
            box-shadow: 0 0 30px var(--neon-blue);
        }

        /* --- ANIMATIONS --- */
        @keyframes popIn {
            from { transform: scale(0); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        @keyframes glitch {
            0% { transform: translate(0) }
            20% { transform: translate(-2px, 2px) }
            40% { transform: translate(-2px, -2px) }
            60% { transform: translate(2px, 2px) }
            80% { transform: translate(2px, -2px) }
            100% { transform: translate(0) }
        }

    </style>
</head>
<body>

    <div id="start-overlay">
        <h1>NEURO SEQUENCE</h1>
        <div style="margin-bottom: 20px; text-align: center; color: #888; max-width: 400px;">
            Hafalkan posisi angka urut dari 1 sampai N.<br>Klik posisi secara berurutan setelah angka tertutup.
        </div>
        <button class="btn" onclick="startGame()">INITIATE SEQUENCE</button>
    </div>

    <div class="hud-container">
        <div class="hud-item">
            <span class="hud-label">Level</span>
            <span class="hud-value" id="level-display">1</span>
        </div>
        <div class="hud-item">
            <span class="hud-label">Sequence</span>
            <span class="hud-value" id="span-display">4</span>
        </div>
        <div class="hud-item">
            <span class="hud-label">Score</span>
            <span class="hud-value" id="score-display">0</span>
        </div>
    </div>

    <div class="game-area" id="grid">
        </div>

    <script>
        // --- GAME CONFIGURATION ---
        const LEVELS = {
            1: { name: "INITIATE", span: 4, grid: 3, timePerNum: 800 },
            2: { name: "ACTIVE", span: 6, grid: 4, timePerNum: 700 },
            3: { name: "SURGE", span: 9, grid: 5, timePerNum: 600 },
            4: { name: "OVERDRIVE", span: 12, grid: 6, timePerNum: 500 },
            5: { name: "MASTER", span: 13, grid: 6, timePerNum: 400 } // Adaptive starts here
        };

        // --- STATE ---
        let currentLevel = 1;
        let currentSpan = 4; // Jumlah angka saat ini
        let currentGridSize = 3;
        let nextNumberToClick = 1;
        let score = 0;
        let isInputLocked = true;
        
        // --- AUDIO SYSTEM (Web Audio API) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playTone(freq, type = 'sine', duration = 0.1) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.value = freq;
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            
            osc.start();
            gain.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + duration);
            osc.stop(audioCtx.currentTime + duration);
        }

        function playSuccessTone(index) {
            // Do-Re-Mi effect: Base freq * interval
            // Pentatonic scale-ish approach for pleasant ascending sounds
            const baseFreq = 300;
            const note = baseFreq + (index * 50); 
            playTone(note, 'sine', 0.2);
        }

        function playErrorTone() {
            playTone(150, 'sawtooth', 0.4);
            playTone(100, 'sawtooth', 0.4);
        }

        function playWinTone() {
            playTone(500, 'square', 0.1);
            setTimeout(() => playTone(700, 'square', 0.1), 100);
            setTimeout(() => playTone(900, 'square', 0.3), 200);
        }

        // --- CORE LOGIC ---

        function startGame() {
            document.getElementById('start-overlay').style.display = 'none';
            if (audioCtx.state === 'suspended') audioCtx.resume();
            loadLevel();
        }

        function loadLevel() {
            // Determine Difficulty
            let config;
            if (currentLevel <= 4) {
                config = LEVELS[currentLevel];
                currentSpan = config.span;
                currentGridSize = config.grid;
            } else {
                // Adaptive Logic for Level 5+
                config = LEVELS[5];
                currentGridSize = 6;
                // currentSpan adjusts dynamically based on win/loss in level 5
            }

            // Update HUD
            document.getElementById('level-display').innerText = currentLevel <= 4 ? currentLevel : "MASTER";
            document.getElementById('span-display').innerText = currentSpan;
            document.getElementById('score-display').innerText = score;

            generateGrid();
        }

        function generateGrid() {
            const gridEl = document.getElementById('grid');
            gridEl.innerHTML = '';
            
            // Set Grid CSS
            gridEl.style.gridTemplateColumns = `repeat(${currentGridSize}, 1fr)`;
            gridEl.style.gridTemplateRows = `repeat(${currentGridSize}, 1fr)`;

            // Create positions array
            const totalCells = currentGridSize * currentGridSize;
            let positions = Array.from({length: totalCells}, (_, i) => i);
            
            // Shuffle positions (Fisher-Yates)
            for (let i = positions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [positions[i], positions[j]] = [positions[j], positions[i]];
            }

            // Determine which positions hold numbers
            let cells = new Array(totalCells).fill(null);
            for(let i=0; i < currentSpan; i++) {
                cells[positions[i]] = i + 1; // Number 1 to N
            }

            // Render Tiles
            cells.forEach((val, index) => {
                const tile = document.createElement('div');
                tile.className = 'tile';
                tile.dataset.index = index;
                
                if (val !== null) {
                    tile.innerText = val;
                    tile.dataset.value = val;
                    tile.classList.add('spawn');
                } else {
                    tile.style.visibility = 'hidden'; // Empty grid slots
                }
                
                // Add click event
                tile.addEventListener('click', () => handleTileClick(tile));
                gridEl.appendChild(tile);
            });

            startSequence();
        }

        function startSequence() {
            nextNumberToClick = 1;
            isInputLocked = true;

            // Calculate exposure time
            // Easy levels give more time per number, hard levels less
            let timePerNum = currentLevel <= 4 ? LEVELS[currentLevel].timePerNum : 400;
            // Total time calculation: base + (span * perNum)
            let exposureTime = 1000 + (currentSpan * timePerNum);
            
            // Adjust for huge spans to avoid waiting too long
            if(exposureTime > 5000) exposureTime = 5000; 

            // Mask Phase
            setTimeout(() => {
                const tiles = document.querySelectorAll('.tile[data-value]');
                tiles.forEach(t => {
                    t.classList.add('masked');
                });
                isInputLocked = false;
            }, exposureTime);
        }

        function handleTileClick(tile) {
            if (isInputLocked) return;
            if (!tile.dataset.value) return; // Ignore empty clicks
            if (tile.classList.contains('correct')) return; // Ignore already clicked

            const value = parseInt(tile.dataset.value);

            if (value === nextNumberToClick) {
                // CORRECT
                tile.classList.remove('masked');
                tile.classList.add('correct');
                playSuccessTone(nextNumberToClick);
                nextNumberToClick++;

                // Check Win Condition
                if (nextNumberToClick > currentSpan) {
                    handleWin();
                }
            } else {
                // WRONG
                tile.classList.remove('masked');
                tile.classList.add('wrong');
                playErrorTone();
                handleLoss();
            }
        }

        function handleWin() {
            isInputLocked = true;
            score += (currentSpan * 10);
            playWinTone();
            
            setTimeout(() => {
                if (currentLevel < 5) {
                    currentLevel++;
                } else {
                    // Adaptive Mode: Increase span
                    currentSpan++; 
                }
                loadLevel();
            }, 1000);
        }

        function handleLoss() {
            isInputLocked = true;
            // Shake Effect on Grid
            const grid = document.getElementById('grid');
            grid.style.transform = "translateX(5px)";
            setTimeout(() => grid.style.transform = "translateX(-5px)", 50);
            setTimeout(() => grid.style.transform = "translateX(0)", 100);

            setTimeout(() => {
                if (currentLevel === 5) {
                    // Adaptive Mode: Decrease span (but not below 4)
                    currentSpan = Math.max(4, currentSpan - 1);
                    alert(`GAME OVER. Sequence Broken. Adaptive Span reset to ${currentSpan}.`);
                    loadLevel();
                } else {
                    alert(`GAME OVER. Final Score: ${score}`);
                    location.reload();
                }
            }, 500);
        }
    </script>
</body>
</html>
